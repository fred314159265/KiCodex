# KiCodex - Agent Guidelines

## Project Overview

KiCodex is a tool that enables KiCad libraries backed by git-trackable flat files.
It serves component library data to KiCad via the HTTP Library API, while storing
the underlying data in formats that produce clean git diffs (CSV, YAML, etc.).

### Core Goals

1. **Interface with KiCad as HTTP libraries** - Implement KiCad's HTTP Library API
   so KiCad sees KiCodex-managed libraries like any other HTTP library.
2. **Git-trackable storage** - Library data is stored in flat files (format TBD,
   see Open Decisions) that produce meaningful diffs and are easy to review in PRs.
3. **Multi-project version isolation** - Multiple KiCad projects can be open
   simultaneously, each using a different version of the libraries. This is achieved
   by including the library data as a git submodule within each project, so each
   project pins its own library version independently.

## Architecture

### System Components

```
+---------------------+       HTTP (localhost)       +------------------+
|       KiCad         | <--------------------------> |  KiCodex Server  |
| (.kicad_httplib     |   Auth token identifies      |  (Rust binary)   |
|  per project)       |   which project/library      |                  |
+---------------------+                              +--------+---------+
                                                              |
                                                     Reads flat files from
                                                     project's library submodule
                                                              |
                                                     +--------+---------+
                                                     |  Library Data    |
                                                     |  (git submodule) |
                                                     |  - resistors.csv |
                                                     |  - capacitors.csv|
                                                     |  - schema.yaml   |
                                                     +------------------+
```

### Components

1. **KiCodex Tray App** (Tauri v2) - Single always-running process with system tray icon.
   Optional start-at-login. Contains:
   - **HTTP server** implementing KiCad's HTTP Library API
   - **Project discovery engine** that detects open KiCad projects
   - **Token-based routing** mapping auth tokens to library filesystem paths
   - Tray icon UI for status, active projects, and configuration

2. **KiCodex Core** (Rust library) - The HTTP server and project discovery logic,
   separated from the Tauri shell so it can be tested independently and run headless
   (e.g., on CI or for users who prefer no tray app).

3. **`kicodex` CLI** - Command-line interface for:
   - `kicodex init` - Initialize a KiCad project to use KiCodex libraries
   - `kicodex serve` - Run the HTTP server without the tray app (headless mode)
   - Other management commands as needed

### Token-Based Project Routing

Each KiCad project gets a unique auth token in its `.kicad_httplib` file. The server
uses this token to determine which project directory (and therefore which version of
the library submodule) to serve data from.

- The `.kicad_httplib` file is **generated and gitignored** (machine-specific).
- The token is generated by `kicodex init` and registered with the server.
- All projects point to the same server URL (`http://localhost:<PORT>/`).
- The server differentiates requests solely by the auth token in the request header.

**Why this works for version isolation:** Project A's token maps to
`/path/to/ProjectA/libs/components/` (submodule at commit abc123), while Project B's
token maps to `/path/to/ProjectB/libs/components/` (submodule at commit def456).
The server reads directly from the flat files on disk, so it always serves whatever
version the submodule is checked out to.

### Project Discovery

The tray app automatically detects open KiCad projects using a layered approach
(all methods work without admin/elevated privileges):

1. **Command line argument scanning** - Enumerate running KiCad processes and read
   their command line arguments. When a user double-clicks a `.kicad_pro` file, the
   path appears in the process args. Works on all platforms:
   - Linux: `/proc/<pid>/cmdline`
   - macOS: `ps -o args` / `sysctl KERN_PROCARGS2`
   - Windows: WMI `Win32_Process.CommandLine`

2. **Lock file watching** - KiCad creates lock files (`.lck`) when a project is open.
   Monitor known project directories for these lock files appearing/disappearing.
   Fully cross-platform, no elevated permissions needed.

When a new project is discovered:
- Check for `kicodex.yaml` in the project directory
- If found, auto-register the library mapping (generate token, write `.kicad_httplib`)
- If the project was previously initialized but the token is stale or duplicated
  (e.g., folder was copied), regenerate with a new token

Previously discovered project paths are cached so lock file monitoring can continue
even when the KiCad process is not running.

### File Layout

**In the KiCad project repo (committed to git):**
```
MyProject/
  kicodex.yaml              # Declares library submodule path(s)
  libs/components/           # Git submodule containing library data
    library.yaml             # Library manifest: table-to-schema mappings
    schemas/                 # Schemas (inline or a nested submodule)
      _base.yaml
      resistor.yaml
      capacitor.yaml
    data/
      resistors.csv
      capacitors.csv
  my_project.kicad_pro
  my_project.kicad_sch
  my_project.kicad_pcb
```

**`library.yaml` (inside the library data submodule):**
```yaml
name: "My Components Library"
schemas_path: schemas        # Relative path to schema directory within this repo

tables:
  - file: data/resistors.csv
    schema: resistor         # References resistor.yaml from schemas_path
    name: "Resistors"        # Display name in KiCad (category name)
  - file: data/capacitors.csv
    schema: capacitor
    name: "Capacitors"
```

This keeps the table-to-schema mapping versioned alongside the data. The schemas
directory can itself be a nested git submodule if shared schema enforcement across
multiple library repos is desired.

**Generated (gitignored):**
```
MyProject/
  libs.kicad_httplib         # Generated by kicodex init, contains server URL + token
```

**`kicodex.yaml` (in the KiCad project repo):**
```yaml
libraries:
  - name: components
    path: libs/components     # Relative path to library data submodule
```

The table-to-schema mapping lives inside the library data submodule itself (see below).

### `kicodex init` Workflow

Run once per project clone:
1. Reads `kicodex.yaml` from the project directory
2. Resolves absolute paths to library submodule(s)
3. Generates a unique token for this project instance
4. Registers the token-to-path mapping with the running server
5. Writes `.kicad_httplib` file (gitignored) with the server URL and token
6. Optionally modifies `.kicad_pro` to add the HTTP library references

### Copied Folder Handling

If a user copies an entire project folder (including the gitignored `.kicad_httplib`),
the copy will initially have the same token as the original, causing it to serve the
original's library data. This is resolved automatically:

- The project discovery engine detects the new project path
- It identifies the token collision (same token, different path)
- It regenerates the `.kicad_httplib` with a new token and registers the new mapping

## Technology Stack

- **Language:** Rust
- **GUI/Tray:** Tauri v2 (system tray support built-in)
- **HTTP Server:** axum 0.8
- **File Watching:** notify crate (cross-platform filesystem events)
- **Process Inspection:** platform-specific APIs wrapped in a cross-platform abstraction
- **CI/CD:** GitHub Actions with `tauri-apps/tauri-action` for cross-platform builds
  - Native builds on ubuntu-latest, macos-latest, windows-latest
  - Produces .msi/.exe (Windows), .dmg/.app (macOS), .deb/.AppImage (Linux)
  - Code signing can be added later (requires Apple Developer account for macOS,
    certificate for Windows)

### Project Structure (Planned)

```
kicodex/
  src-tauri/                 # Tauri app (tray icon, system integration)
  kicodex-core/              # Core library (HTTP server, project discovery, file parsing)
  kicodex-cli/               # CLI binary wrapping core library
  .github/workflows/         # CI/CD pipelines
```

## Library Data Format

**Decided:** CSV with one file per component type/table (e.g., `resistors.csv`,
`capacitors.csv`). Each CSV conforms to a schema that defines required and optional
fields for that component type.

## Schema System

### Overview

Schemas define the fields for each component type. They use YAML format and support
inheritance from a base template. Schemas are version-tracked in git (either within
the library data submodule or as a separate submodule for cross-library enforcement).

### Schema Inheritance

A `_base.yaml` schema defines fields common to all components. Type-specific schemas
inherit from base and add their own fields.

**`_base.yaml` example:**
```yaml
fields:
  mpn:
    display_name: "MPN"
    required: true
    description: "Manufacturer Part Number"
  manufacturer:
    display_name: "Manufacturer"
    required: true
  description:
    display_name: "Description"
    required: true
  value:
    display_name: "Value"
    required: true
  symbol:
    display_name: "Symbol"
    required: true
    type: kicad_symbol
  footprint:
    display_name: "Footprint"
    required: true
    type: kicad_footprint
  reference:
    display_name: "reference"
    required: false
  datasheet:
    display_name: "Datasheet"
    required: false
    type: url
```

**`resistor.yaml` example:**
```yaml
inherits: _base
exclude_from_sim: true
fields:
  resistance:
    display_name: "Resistance"
    required: true
    visible: true
  tolerance:
    display_name: "Tolerance"
    required: false
  power_rating:
    display_name: "Power Rating"
    required: false
  package:
    display_name: "Package"
    required: true
```

### Field Handling Policy

- **Required fields** (from schema): Must be present in the CSV. Validation fails
  without them.
- **Optional fields** (from schema): Recognized by the system, may receive special
  treatment (type checking, display hints). Not required to be present.
- **Free-form fields**: Extra CSV columns not defined in the schema are passed through
  to KiCad as custom fields with no error or warning. This allows users to add
  supplier part numbers, internal notes, or any other data without modifying the schema.

### Field Visibility

Field visibility controls whether a field is shown on the schematic when a component
is placed. The `visible` property in the schema field definition controls this.

- **`value` and `reference`** are always visible (these are core KiCad fields).
- **All other fields** default to hidden unless the schema explicitly sets
  `visible: true`.
- Fields not defined in the schema (free-form CSV columns) are also hidden by default.

The field's `display_name` from the schema is used as the key in the API response
(e.g., a CSV column `mpn` with `display_name: "MPN"` appears as `"MPN"` in the
KiCad fields list).

### Exclude Flags

KiCad supports three exclusion flags on components: `exclude_from_bom`,
`exclude_from_board`, and `exclude_from_sim`. These control whether a component
appears in the BOM, is placed on the board, or is included in simulation.

All three default to `false` (component is included everywhere). They can be
configured at two levels, with CSV overriding schema:

1. **Schema level** — applies to all parts of that type:
   ```yaml
   # resistor.yaml
   inherits: _base
   exclude_from_sim: true
   ```

2. **CSV column override** — per-part exceptions:
   ```csv
   id,mpn,...,exclude_from_bom
   1,TP-1,...,true
   ```

Priority: CSV column > schema default > `false`.

Accepted CSV values for boolean flags: `true`/`1`/`yes` → `"True"`, anything else
→ `"False"`.

### Schema as a Submodule

Schemas can be tracked in a separate git repository and included as a submodule.
This allows:
- Enforcing the same schema across multiple library repositories
- Version-tracking schema evolution independently from component data
- Sharing schemas across teams or organizations

```
libs/
  schemas/              # Git submodule (shared schema repo)
    _base.yaml
    resistor.yaml
    capacitor.yaml
  components/           # Git submodule (component data)
    resistors.csv
    capacitors.csv
```

Alternatively, schemas can live inside the library data submodule if cross-library
enforcement is not needed.

### Shipped Templates

KiCodex ships with a minimal set of built-in schemas:
- `_base.yaml` — common fields for all components
- `resistor.yaml` — example type-specific schema

Users are expected to define their own schemas for other component types based on
their specific needs.

## Open Decisions

### HTTP Server Port
**Decided:** Fixed default port (e.g., `18734`) with configurable override in the
global KiCodex config file. The port must be consistent across restarts since it is
embedded in generated `.kicad_httplib` files.

Global config location (platform-appropriate):
- Linux: `~/.config/kicodex/config.yaml`
- macOS: `~/Library/Application Support/kicodex/config.yaml`
- Windows: `%APPDATA%\kicodex\config.yaml`

```yaml
# config.yaml
server:
  port: 18734    # Default, change if port conflicts
```

### KiCad Project File Modification
**Decided:** `kicodex init` should prompt the user whether to automatically modify
the `.kicad_pro` file to register the HTTP library. If declined, it generates the
`.kicad_httplib` and instructs the user to add it manually via KiCad's library manager.
The auto-discovery (tray app) should also ask before modifying project files.

## KiCad HTTP Library API

Reference: https://dev-docs.kicad.org/en/apis-and-binding/http-libraries/index.html

### `.kicad_httplib` File Format

```json
{
  "meta": { "version": 1.0 },
  "name": "KiCodex Library",
  "description": "Component library served by KiCodex",
  "source": {
    "type": "REST_API",
    "api_version": "v1",
    "root_url": "http://127.0.0.1:18734",
    "token": "<unique-project-token>",
    "timeout_parts_seconds": 60,
    "timeout_categories_seconds": 600
  }
}
```

### Authentication

KiCad sends the token as: `Authorization: Token <token_string>`
(Note: uses `Token` prefix, NOT `Bearer`.)

This is how the server identifies which project is making the request.

### API Endpoints

The server must implement four endpoints. All responses must use HTTP 200 on success.
**All values in responses must be strings** (including numbers and booleans).

#### 1. Root / Endpoint Discovery
`GET {root_url}/v1/`
```json
{
  "categories": "",
  "parts": ""
}
```

#### 2. Categories (maps to library tables)
`GET {root_url}/v1/categories.json`
```json
[
  { "id": "1", "name": "Resistors", "description": "SMD and through-hole resistors" },
  { "id": "2", "name": "Capacitors", "description": "Ceramic and electrolytic capacitors" }
]
```
Categories appear as **libraries** in KiCad's Symbol Chooser.

#### 3. Parts by Category
`GET {root_url}/v1/parts/category/{categoryId}.json`
```json
[
  { "id": "1", "name": "RC0603FR-0710KL", "description": "RES 10K OHM 1% 1/10W 0603" },
  { "id": "2", "name": "RC0603FR-07100KL", "description": "RES 100K OHM 1% 1/10W 0603" }
]
```

#### 4. Part Details
`GET {root_url}/v1/parts/{partId}.json`
```json
{
  "id": "1",
  "name": "RC0603FR-0710KL",
  "symbolIdStr": "Device:R",
  "exclude_from_bom": "False",
  "exclude_from_board": "False",
  "exclude_from_sim": "False",
  "fields": {
    "reference": { "value": "R" },
    "Value": { "value": "10K" },
    "MPN": { "value": "RC0603FR-0710KL", "visible": "False" },
    "Manufacturer": { "value": "Yageo", "visible": "False" },
    "Description": { "value": "RES 10K OHM 1% 1/10W 0603", "visible": "False" },
    "Footprint": { "value": "Resistor_SMD:R_0603_1608Metric", "visible": "False" },
    "Datasheet": { "value": "https://example.com/datasheet.pdf", "visible": "False" },
    "Resistance": { "value": "10K", "visible": "False" },
    "Package": { "value": "0603", "visible": "False" }
  }
}
```
Note: Field keys use the `display_name` from the schema (e.g., `"MPN"` not `"mpn"`).
Fields without `"visible"` default to visible in KiCad; the server only emits
`"visible": "False"` for hidden fields.

### Key Implementation Notes

- HTTP libraries are **read-only** (KiCad fetches data, cannot write back).
- `symbolIdStr` references a symbol that must exist in locally installed KiCad
  libraries (format: `LibraryName:SymbolName`, e.g., `Device:R`).
- `fields.footprint.value` similarly references a local footprint
  (format: `LibraryName:FootprintName`, e.g., `Resistor_SMD:R_0603_1608Metric`).
- `fields.reference.value` is the reference designator prefix (e.g., `R`, `C`, `U`).
- The `fields` dict can contain **unlimited custom fields**. Each field must have
  a `value` key and optionally a `visible` key (KiCad defaults to visible if omitted).
- KiCodex only emits `"visible": "False"` for hidden fields; visible fields omit the
  key entirely. `value` and `reference` are always visible; all other fields are hidden
  unless the schema sets `visible: true`.
- Any non-200 response causes KiCad to show an error and ignore the result.

### Mapping from CSV/Schema to API

| CSV/Schema concept | API field |
|---|---|
| Table file (resistors.csv) | Category (returned by categories endpoint) |
| Row in CSV | Part (returned by parts endpoints) |
| `id` column | `id` field on parts (see Part ID Management) |
| `symbol` column (from _base schema) | `symbolIdStr` top-level field |
| `exclude_from_bom` column / schema flag | `exclude_from_bom` top-level field |
| `exclude_from_board` column / schema flag | `exclude_from_board` top-level field |
| `exclude_from_sim` column / schema flag | `exclude_from_sim` top-level field |
| All other columns | Entries in `fields` dict, keyed by schema `display_name` |
| Field `visible` property in schema | `fields.<name>.visible` (omitted if visible) |

Columns `id`, `symbol`, `exclude_from_bom`, `exclude_from_board`, and
`exclude_from_sim` are top-level API fields and do **not** appear in the `fields`
dict.

## Part ID Management

Each part (CSV row) needs a stable unique ID for the HTTP API. The `id` column is
part of the base schema and is **mandatory in the CSV file**.

1. **User-provided IDs are respected** — if a row has an `id` value, it is used as-is.
2. **Missing IDs are auto-generated AND written back to the CSV immediately** — when
   the server encounters a row without an `id`, it generates one and writes it back
   to the CSV file on disk. This is NOT optional; IDs must be persisted so they remain
   consistent from that point forward. The CSV file will be modified in-place.
3. **Duplicate IDs are detected** — the server assigns a new unique ID to the
   duplicate row and writes it back to the CSV immediately, with a warning logged.

The `id` column should be the first column in the CSV for visibility. IDs should be
short, human-readable where possible (e.g., incrementing integers), but the system
must handle any string value.

**Important:** Because the server may write to CSV files (for ID assignment), the
library submodule may have uncommitted changes after new parts are added. Users should
commit these changes to persist the assigned IDs.

## Planned GUI Features

The Tauri tray app will eventually include a full GUI for library management beyond
just serving HTTP requests. Key planned features:

### Library Table Editor
- Browse, add, edit, and delete components in CSV tables via a GUI
- Schema-aware: form fields match the schema for the component type, with required
  fields highlighted and validated
- Free-form fields can be added on the fly
- Changes are written directly to the CSV files (and are therefore git-trackable)

### Symbol and Footprint Picker
A visual picker that helps users select valid KiCad symbols and footprints when
adding/editing components. This picker should:
- Read available symbols from KiCad's **global library configuration**
  (`kicad_sym` libraries configured system-wide)
- Read **project-specific libraries** from the relevant `.kicad_pro` file
- Present a browsable/searchable list with previews where possible
- Populate the `symbol` and `footprint` fields in the component editor

**Implementation note:** This requires parsing KiCad's library configuration files
to discover available symbols/footprints. Key files to investigate:
- Global sym-lib-table: `~/.config/kicad/<version>/sym-lib-table` (Linux),
  `~/Library/Preferences/kicad/<version>/sym-lib-table` (macOS),
  `%APPDATA%\kicad\<version>\sym-lib-table` (Windows)
- Project-specific: `<project>.kicad_pro` or `sym-lib-table` in project directory
- Similar for footprints (`fp-lib-table`)

### Library Reference Validation
Using the same KiCad library awareness as the symbol/footprint picker, the validation
system (`kicodex validate`) should check that all symbol and footprint references in
the CSV tables actually exist in the user's KiCad installation:

- Verify `symbol` column values (e.g., `Device:R`) against the available symbol
  libraries (global + project-specific)
- Verify `footprint` column values (e.g., `Resistor_SMD:R_0603_1608Metric`) against
  the available footprint libraries
- Report missing/invalid references with clear error messages
- Optionally run validation on server startup and warn about broken references
- The tray app could show a warning indicator when libraries have validation issues

**Note:** This validation is inherently machine-specific (depends on installed KiCad
libraries) and optionally project-specific (depends on project library configuration).
It should be a helpful warning, not a hard block — components with missing symbols
can still be served via the HTTP API; KiCad will show its own error when the user
tries to place them.

## Development Guidelines

- The core library (`kicodex-core`) must be independent of Tauri and usable in
  headless/CLI mode.
- All platform-specific code (process scanning, file handle enumeration) must be
  behind a clean cross-platform abstraction.
- The HTTP server must correctly implement KiCad's HTTP Library API specification.
- Generated files (`.kicad_httplib`) should include a comment indicating they were
  generated by KiCodex and should not be edited manually.
- Prefer simple, correct implementations over clever optimizations.
